# Catalog of Elixir-specific code smells

## Introduction

[Elixir](https://elixir-lang.org/) is a new functional programming language whose popularity is rising in the industry <sup>[link](https://elixir-companies.com/)</sup>. However, there are few works in the scientific literature focused on studying the internal quality of systems implemented in this language.

In order to better understand the types of sub-optimal code structures that can harm the internal quality of Elixir systems, we scoured websites, blogs, forums, and videos (grey literature review), looking for specific code smells for Elixir that are discussed by its developers.

As a result of this investigation, we have initially proposed a catalog of 18 new smells that are specific to Elixir systems. Other smells are being suggested by the community, so this catalog is constantly being updated __(currently 22 smells)__. These code smells are categorized into two different groups ([design-related](#design-related-smells) and [low-level concerns](#low-level-concerns-smells)), according to the type of impact and code extent they affect. This catalog of Elixir-specific code smells is presented below. Each code smell is documented using the following structure:

* __Name:__ Unique identifier of the code smell. This name is important to facilitate communication between developers;
* __Category:__ The portion of code affected by smell and its severity;
* __Problem:__ How the code smell can harm code quality and what impacts this can have for developers;
* __Example:__ Code and textual descriptions to illustrate the occurrence of the code smell;
* __Refactoring:__ Ways to change smelly code in order to improve its qualities. Examples of refactored code are presented to illustrate these changes.

The objective of this catalog of code smells is to instigate the improvement of the quality of code developed in Elixir. For this reason, we are interested in knowing Elixir's community opinion about these code smells: *Do you agree that these code smells can be harmful? Have you seen any of them in production code? Do you have any suggestions about some Elixir-specific code smell not cataloged by us?...*

Please feel free to make pull requests and suggestions ([Issues](https://github.com/lucasvegi/Elixir-Code-Smells/issues) tab). We want to hear from you!

## Design-related smells

Design-related smells are more complex, affect a coarse-grained code element, and are therefore harder to detect. In this section, 13 different smells classified as design-related are explained and exemplified:

<!-- livebook:{"branch_parent_index":1} -->

## GenServer Envy

* __Category:__ Design-related smell.

* __Problem:__ In Elixir, processes can be primitively created by `Kernel.spawn/1`, `Kernel.spawn/3`, `Kernel.spawn_link/1` and `Kernel.spawn_link/3` functions. Although it is possible to create them this way, it is more common to use abstractions (e.g., [`Agent`](https://hexdocs.pm/elixir/1.13/Agent.html), [`Task`](https://hexdocs.pm/elixir/1.13/Task.html), and [`GenServer`](https://hexdocs.pm/elixir/master/GenServer.html)) provided by Elixir to create processes. The use of each specific abstraction is not a code smell in itself; however, there can be trouble when either a `Task` or `Agent` is used beyond its suggested purposes, being treated like a `GenServer`.

* __Example:__ As shown next, `Agent` and `Task` are abstractions to create processes with specialized purposes. In contrast, `GenServer` is a more generic abstraction used to create processes for many different purposes:

  * `Agent`: As Elixir works on the principle of immutability, by default no value is shared between multiple places of code, enabling read and write as in a global variable. An `Agent` is a simple process abstraction focused on solving this limitation, enabling processes to share state.
  * `Task`: This process abstraction is used when we only need to execute some specific action asynchronously, often in an isolated way, without communication with other processes.
  * `GenServer`: This is the most generic process abstraction. The main benefit of this abstraction is explicitly segregating the server and the client roles, thus providing a better API for the organization of processes communication. Besides that, a `GenServer` can also encapsulate state (like an `Agent`), provide sync and async calls (like a `Task`), and more.

  Examples of this code smell appear when `Agents` or `Tasks` are used for general purposes and not only for specialized ones such as their documentation suggests. To illustrate some smell occurrences, we will cite two specific situations. 1) When a `Task` is used not only to async execute an action, but also to frequently exchange messages with other processes; 2) When an `Agent`, beside sharing some global value between processes, is also frequently used to execute isolated tasks that are not of interest to other processes.

* __Refactoring:__ When an `Agent` or `Task` goes beyond its suggested use cases and becomes painful, it is better to refactor it into a `GenServer`.

<!-- livebook:{"branch_parent_index":1} -->

## Agent Obsession

* __Category:__ Design-related smell.

* __Problem:__ In Elixir, an `Agent` is a process abstraction focused on sharing information between processes by means of message passing. It is a simple wrapper around shared information, thus facilitating its read and update from any place in the code. The use of an `Agent` to share information is not a code smell in itself; however, when the responsibility for interacting directly with an `Agent` is spread across the entire system, this can be problematic. This bad practice can increase the difficulty of code maintenance and make the code more prone to bugs.

* __Example:__ The following code seeks to illustrate this smell. The responsibility for interacting directly with the `Agent` is spread across four different modules (i.e, `A`, `B`, `C`, and `D`).

```elixir
defmodule A do
  # ...
  def update(pid) do
    # ...
    Agent.update(pid, fn _list -> 123 end)
    # ...
  end
end
```

```elixir
defmodule B do
  # ...
  def update(pid) do
    # ...
    Agent.update(pid, fn content -> %{a: content} end)
    # ...
  end
end
```

```elixir
defmodule C do
  # ...
  def update(pid) do
    # ...
    Agent.update(pid, fn content -> [:atom_value | [content]] end)
    # ...
  end
end
```

```elixir
defmodule D do
  # ...
  def get(pid) do
    # ...
    Agent.get(pid, fn content -> content end)
    # ...
  end
end
```

This spreading of responsibility can generate duplicated code and make code maintenance more difficult. Also, due to the lack of control over the format of the shared data, complex composed data can be shared. This freedom to use any format of data is dangerous and can induce developers to introduce bugs.

```elixir
# start an agent with initial state of an empty list
{:ok, agent} = Agent.start_link(fn -> [] end)
# {:ok, #PID<0.135.0>}

# many data format (i.e., List, Map, Integer, Atom) are
# combined through direct access spread across the entire system
A.update(agent)
B.update(agent)
C.update(agent)

# state of shared information
D.get(agent)
# [:atom_value, %{a: 123}]
```

* __Refactoring:__ Instead of spreading direct access to an `Agent` over many places in the code, it is better to refactor this code by centralizing the responsibility for interacting with an `Agent` in a single module. This refactoring improves the maintainability by removing duplicated code; it also allows you to limit the accepted format for shared data, reducing bug-proneness. As shown below, the module `KV.Bucket` is centralizing the responsibility for interacting with the `Agent`. Any other place in the code that needs to access shared data must now delegate this action to `KV.Bucket`. Also, `KV.Bucket` now only allows data to be shared in `Map` format.

```elixir
defmodule KV.Bucket do
  use Agent

  @doc """
  Starts a new bucket.
  """
  def start_link(_opts) do
    Agent.start_link(fn -> %{} end)
  end

  @doc """
  Gets a value from the `bucket` by `key`.
  """
  def get(bucket, key) do
    Agent.get(bucket, &Map.get(&1, key))
  end

  @doc """
  Puts the `value` for the given `key` in the `bucket`.
  """
  def put(bucket, key, value) do
    Agent.update(bucket, &Map.put(&1, key, value))
  end
end
```

The following are examples of how to delegate access to shared data (provided by an `Agent`) to `KV.Bucket`.

```elixir
# start an agent through a `KV.Bucket`
{:ok, bucket} = KV.Bucket.start_link(%{})
# {:ok, #PID<0.114.0>}

# add shared values to the keys `milk` and `beer`
KV.Bucket.put(bucket, "milk", 3)
KV.Bucket.put(bucket, "beer", 7)

# accessing shared data of specific keys
KV.Bucket.get(bucket, "beer")
# 7
KV.Bucket.get(bucket, "milk")
# 3
```

These examples are based on code written in Elixir's official documentation. Source: [link](https://elixir-lang.org/getting-started/mix-otp/agent.html#agents)

<!-- livebook:{"branch_parent_index":1} -->

## Unsupervised process

* __Category:__ Design-related smell.

* __Problem:__ In Elixir, creating a process outside a supervision tree is not a code smell in itself. However, when code creates a large number of long-running processes outside a supervision tree, this can make visibility and monitoring of these processes difficult, preventing developers from fully controlling their applications.

* __Example:__ The following code example seeks to illustrate a library responsible for maintaining a numerical `Counter` through a `GenServer` process outside a supervision tree. Multiple counters can be created simultaneously by a client (one process for each counter), making these unsupervised processes difficult to manage. This can cause problems with the initialization, restart, and shutdown of a system.

```elixir
defmodule Counter do
  use GenServer

  @moduledoc """
    Global counter implemented through a GenServer process
    outside a supervision tree.
  """

  @doc """
    Function to create a counter.
      initial_value: any integer value.
      pid_name: optional parameter to define the process name.
                Default is Counter.
  """
  def start(initial_value, pid_name \\ __MODULE__)
      when is_integer(initial_value) do
    GenServer.start(__MODULE__, initial_value, name: pid_name)
  end

  @doc """
    Function to get the counter's current value.
      pid_name: optional parameter to inform the process name.
                Default is Counter.
  """
  def get(pid_name \\ __MODULE__) do
    GenServer.call(pid_name, :get)
  end

  @doc """
    Function to changes the counter's current value.
    Returns the updated value.
      value: amount to be added to the counter.
      pid_name: optional parameter to inform the process name.
                Default is Counter.
  """
  def bump(value, pid_name \\ __MODULE__) do
    GenServer.call(pid_name, {:bump, value})
    get(pid_name)
  end

  ## Callbacks

  @impl true
  def init(counter) do
    {:ok, counter}
  end

  @impl true
  def handle_call(:get, _from, counter) do
    {:reply, counter, counter}
  end

  def handle_call({:bump, value}, _from, counter) do
    {:reply, counter, counter + value}
  end
end

# ...Use examples...

Counter.start(0)
# {:ok, #PID<0.115.0>}

Counter.get()
# 0

Counter.start(15, C2)
# {:ok, #PID<0.120.0>}

Counter.get(C2)
# 15

Counter.bump(-3, C2)
# 12

Counter.bump(7)
# 7
```

* __Refactoring:__ To ensure that clients of a library have full control over their systems, regardless of the number of processes used and the lifetime of each one, all processes must be started inside a supervision tree. As shown below, this code uses a `Supervisor` <sup>[link](https://hexdocs.pm/elixir/master/Supervisor.html)</sup> as a supervision tree. When this Elixir application is started, two different counters (`Counter` and `C2`) are also started as child processes of the `Supervisor` named `App.Supervisor`. Both are initialized with zero. By means of this supervision tree, it is possible to manage the lifecycle of all child processes (e.g., stopping or restarting each one), improving the visibility of the entire app.

  ```elixir
  defmodule SupervisedProcess.Application do
    use Application

    @impl true
    def start(_type, _args) do
      children = [
        # The counters are Supervisor children started via Counter.start(0).
        %{
          id: Counter,
          start: {Counter, :start, [0]}
        },
        %{
          id: C2,
          start: {Counter, :start, [0, C2]}
        }
      ]

      opts = [strategy: :one_for_one, name: App.Supervisor]
      Supervisor.start_link(children, opts)
    end
  end

  #...Use examples...

  iex(1)> Supervisor.count_children(App.Supervisor)
  %{active: 2, specs: 2, supervisors: 0, workers: 2}

  iex(2)> Counter.get(Counter)
  0

  iex(3)> Counter.get(C2)
  0

  iex(4)> Counter.bump(7, Counter)
  7

  iex(5)> Supervisor.terminate_child(App.Supervisor, Counter)
  iex(6)> Supervisor.count_children(App.Supervisor)
  %{active: 1, specs: 2, supervisors: 0, workers: 2}  #only one active

  iex(7)> Counter.get(Counter)   #Error because it was previously terminated
  ** (EXIT) no process: the process is not alive...

  iex(8)> Supervisor.restart_child(App.Supervisor, Counter)
  iex(9)> Counter.get(Counter)   #after the restart, this process can be accessed again
  0
  ```

  These examples are based on codes written in Elixir's official documentation. Source: [link](https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-spawning-unsupervised-processes)

<!-- livebook:{"branch_parent_index":1} -->

## Large messages between processes

* __Category:__ Design-related smell.

* __Problem:__ In Elixir, processes run in an isolated manner, often concurrently with other Elixir. Communication between different processes is performed via message passing. The exchange of messages between processes is not a code smell in itself; however, when processes exchange messages, their contents are copied between them. For this reason, if a huge structure is sent as a message from one process to another, the sender can become blocked, compromising performance. If these large message exchanges occur frequently, the prolonged and frequent blocking of processes can cause a system to behave anomalously.

* __Example:__ The following code is composed of two modules which will each run in a different process. As the names suggest, the `Sender` module has a function responsible for sending messages from one process to another (i.e., `send_msg/3`). The `Receiver` module has a function to create a process to receive messages (i.e., `create/0`) and another one to handle the received messages (i.e., `run/0`). If a huge structure, such as a list with 1_000_000 different values, is sent frequently from `Sender` to `Receiver`, the impacts of this smell could be felt.

```elixir
defmodule Receiver do
  @doc """
    Function for receiving messages from processes.
  """
  def run do
    receive do
      {:msg, msg_received} -> msg_received
      {_, _} -> "won't match"
    end
  end

  @doc """
    Create a process to receive a message.
    Messages are received in the run() function of Receiver.
  """
  def create do
    spawn(Receiver, :run, [])
  end
end
```

```elixir
defmodule Sender do
  @doc """
    Function for sending messages between processes.
      pid_receiver: message recipient.
      msg: messages of any type and size can be sent.
      id_msg: used by receiver to decide what to do
              when a message arrives.
              Default is the atom :msg
  """
  def send_msg(pid_receiver, msg, id_msg \\ :msg) do
    send(pid_receiver, {id_msg, msg})
  end
end
```

Examples of large messages between processes:

```elixir
pid = Receiver.create()
# PID<0.144.0>

# Simulating a message with large content - List with length 1_000_000
msg = %{from: inspect(self()), to: inspect(pid), content: Enum.to_list(1..1_000_000)}

Sender.send_msg(pid, msg)
# {:msg,
#   %{
#     content: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#       20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
#       39, 40, 41, 42, 43, 44, 45, 46, 47, ...],
#     from: "#PID<0.105.0>",
#     to: "#PID<0.144.0>"
#   }}
```

This example is based on a original code by Samuel Mullen. Source: [link](https://samuelmullen.com/articles/elixir-processes-send-and-receive/)

<!-- livebook:{"branch_parent_index":1} -->

## Complex multi-clause function

* __Category:__ Design-related smell.

* __Problem:__ Using multi-clause functions in Elixir, to group functions of the same name, is not a code smell in itself. However, due to the great flexibility provided by this programming feature, some developers may abuse the number of guard clauses and pattern matches when defining these grouped functions.

* __Example:__ A recurrent example of abusive use of the multi-clause functions is when we're trying to mix too much business logic into the function definitions. This makes it difficult to read and understand the logic involved in the functions, which may impair code maintainability. Some developers use documentation mechanisms such as `@doc` annotations to compensate for poor code readability, but unfortunately, with a multi-clause function, we can only use these annotations once per function name, particularly on the first or header function. As shown next, all other variations of the function need to be documented only with comments, a mechanism that cannot automate tests, leaving the code prone to bugs.

```elixir
defmodule Product do
  defstruct count: nil, material: nil
end
```

```elixir
defmodule Animal do
  defstruct count: nil, skin: nil
end
```

```elixir
defmodule MultiClause do
  @doc """
    Update sharp product with 0 or empty count
    
    ## Examples

      iex> Namespace.Module.update(...)
      expected result...   
  """
  def update(%Product{count: nil, material: material})
      when material in ["metal", "glass"] do
    # ...
  end

  # update blunt product
  def update(%Product{count: count, material: material})
      when count > 0 and material in ["metal", "glass"] do
    # ...
  end

  # update animal...
  def update(%Animal{count: 1, skin: skin})
      when skin in ["fur", "hairy"] do
    # ...
  end
end
```

* __Refactoring:__ As shown below, a possible solution to this smell is to break the business rules that are mixed up in a single complex multi-clause function in several different simple functions. Each function can have a specific `@doc`, describing its behavior and parameters received. While this refactoring sounds simple, it can have a lot of impact on the function's current clients, so be careful!

```elixir
defmodule MultiClauseRefactoring do
  @doc """
  Update sharp product

  ## Parameter
    struct: %Product{...}

  ## Examples

    iex> Namespace.Module.update_sharp_product(%Product{...})
    expected result...   
  """
  def update_sharp_product(struct) do
    # ...
  end

  @doc """
    Update blunt product

    ## Parameter
      struct: %Product{...}
    
    ## Examples

      iex> Namespace.Module.update_blunt_product(%Product{...})
      expected result...   
  """
  def update_blunt_product(struct) do
    # ...
  end

  @doc """
    Update animal

    ## Parameter
      struct: %Animal{...}
    
    ## Examples

      iex> Namespace.Module.update_animal(%Animal{...})
      expected result...   
  """
  def update_animal(struct) do
    # ...
  end
end
```

This example is based on a original code by Syamil MJ ([@syamilmj](https://github.com/syamilmj)). Source: [link](https://syamilmj.com/2021-09-01-elixir-multi-clause-anti-pattern/)

<!-- livebook:{"branch_parent_index":1} -->

## Complex extraction in clauses

* __Category:__ Design-related smell.

* __Note:__ This smell was suggested by the community via issues ([#9](https://github.com/lucasvegi/Elixir-Code-Smells/issues/9)).

* __Problem:__ When we use multi-clause functions, it is possible to extract values in the clauses for further usage and for pattern matching/guard checking. This extraction itself does not represent a code smell, but when you have too many clauses or too many arguments, it becomes hard to know which extracted parts are used for pattern/guards and what is used only inside the function body. This smell is related to [Complex multi-clause function](#complex-multi-clause-function), but with implications of its own. It impairs the code readability in a different way.

* __Example:__ The following code, although simple, tries to illustrate the occurrence of this code smell. The multi-clause function `drive/1` is extracting fields of an `%User{}` struct in its clauses for further usage (`name`) and for pattern/guard checking (`age`).

```elixir
defmodule User do
  defstruct name: nil, age: nil
end
```

```elixir
defmodule ExtractionInClauses do
  def drive(%User{name: name, age: age}) when age >= 18 do
    "#{name} can drive"
  end

  def drive(%User{name: name, age: age}) when age < 18 do
    "#{name} cannot drive"
  end
end
```

While the example is small and looks like a clear code, try to imagine a situation where `drive/1` was more complex, having many more clauses, arguments, and extractions. This is the really smelly code!

* __Refactoring:__ As shown below, a possible solution to this smell is to extract only pattern/guard related variables in the signature once you have many arguments or multiple clauses:

```elixir
defmodule ExtractionInClausesRefactoring do
  def drive(%User{age: age} = user) when age >= 18 do
    %User{name: name} = user
    "#{name} can drive"
  end

  def drive(%User{age: age} = user) when age < 18 do
    %User{name: name} = user
    "#{name} cannot drive"
  end
end
```

This example and the refactoring are proposed by José Valim ([@josevalim](https://github.com/josevalim))

<!-- livebook:{"branch_parent_index":1} -->

## Complex branching

* __Category:__ Design-related smell.

* __Note:__ Formerly known as "Complex API error handling".

* __Problem:__ When a function assumes the responsibility of handling multiple errors alone, it can increase its cyclomatic complexity (metric of control-flow) and become incomprehensible. This situation can configure a specific instance of "Long function", a traditional code smell, but has implications of its own. Under these circumstances, this function could get very confusing, difficult to maintain and test, and therefore bug-proneness.

* __Example:__ An example of this code smell is when a function uses the `case` control-flow structure or other similar constructs (e.g., `cond`, or `receive`) to handle multiple variations of response types returned by the same API endpoint. This practice can make the function more complex, long, and difficult to understand, as shown next.

  ```elixir
  def get_customer(customer_id) do
    case get("/customers/#{customer_id}") do
      {:ok, %Tesla.Env{status: 200, body: body}} -> {:ok, body}
      {:ok, %Tesla.Env{body: body}} -> {:error, body}
      {:error, _} = other -> other
    end
  end
  ```

  Although `get_customer/1` is not really long in this example, it could be. Thinking about this more complex scenario, where a large number of different responses can be provided to the same endpoint, is not a good idea to concentrate all on a single function. This is a risky scenario, where a little typo, or any problem introduced by the programmer in handling a response type, could eventually compromise the handling of all responses from the endpoint (if the function raises an exception, for example).

* __Refactoring:__ As shown below, in this situation, instead of concentrating all handlings within the same function,  creating a complex branching, it is better to delegate each branch (handling of a response type) to a different private function. In this way, the code will be cleaner, more concise, and readable.

  ```elixir
  def get_customer(customer_id) when is_integer(customer_id) do
    case get("/customers/#{customer_id}") do
      {:ok, %Tesla.Env{status: 200, body: body}} -> success_api_response(body)
      {:ok, %Tesla.Env{body: body}} -> x_error_api_response(body)
      {:error, _} = other -> y_error_api_response(other)
    end
  end

  defp success_api_response(body) do
    {:ok, body}
  end

  defp x_error_api_response(body) do
    {:error, body}
  end

  defp y_error_api_response(other) do
    other
  end
  ```

  While this example of refactoring `get_customer/1` might seem quite more verbose than the original code, remember to imagine a scenario where `get_customer/1` is responsible for handling a number much larger than three different types of possible responses. This is the smelly scenario!

  This example is based on code written by Zack <sup>[MrDoops](https://elixirforum.com/u/MrDoops)</sup> and Dimitar Panayotov <sup>[dimitarvp](https://elixirforum.com/u/dimitarvp)</sup>. Source: [link](https://elixirforum.com/t/what-are-sort-of-smells-do-you-tend-to-find-in-elixir-code/14971). We got suggestions from José Valim ([@josevalim](https://github.com/josevalim)) on the refactoring.

<!-- livebook:{"branch_parent_index":1} -->

## Complex else clauses in with

* __Category:__ Design-related smell.

* __Note:__ This smell was suggested by the community via issues ([#7](https://github.com/lucasvegi/Elixir-Code-Smells/issues/7)).

* __Problem:__ This code smell refers to `with` statements that flatten all its error clauses into a single complex `else` block. This situation is harmful to the code readability and maintainability because difficult to know from which clause the error value came.

* __Example:__ An example of this code smell, as shown below, is a function `open_decoded_file/1` that read a base 64 encoded string content from a file and returns a decoded binary string. This function uses a `with` statement that needs to handle two possible errors, all of which are concentrated in a single complex `else` block.

```elixir
defmodule ElseClauses do
  def open_decoded_file(path) do
    with {:ok, encoded} <- File.read(path),
         {:ok, value} <- Base.decode64(encoded) do
      value
    else
      {:error, _} -> :badfile
      :error -> :badencoding
    end
  end
end
```

* __Refactoring:__ As shown below, in this situation, instead of concentrating all error handlings within a single complex `else` block, it is better to normalize the return types in specific private functions. In this way, due to its organization, the code will be cleaner and more readable.

```elixir
defmodule ElseClausesRefactoring do
  def open_decoded_file(path) do
    with {:ok, encoded} <- file_read(path),
         {:ok, value} <- base_decode64(encoded) do
      value
    end
  end

  defp file_read(path) do
    case File.read(path) do
      {:ok, contents} -> {:ok, contents}
      {:error, _} -> :badfile
    end
  end

  defp base_decode64(contents) do
    case Base.decode64(contents) do
      {:ok, contents} -> {:ok, contents}
      :error -> :badencoding
    end
  end
end
```

This example and the refactoring are proposed by José Valim ([@josevalim](https://github.com/josevalim))

<!-- livebook:{"branch_parent_index":1} -->

## Exceptions for control-flow

* __Category:__ Design-related smell.

* __Problem:__ This smell refers to code that forces developers to handle exceptions for control-flow. Exception handling itself does not represent a code smell, but this should not be the only alternative available to developers to handle an error in client code. When developers have no freedom to decide if an error is exceptional or not, this is considered a code smell.

* __Example:__ An example of this code smell, as shown below, is when a library (e.g. `MyModule`) forces its clients to use `try .. rescue` statements to capture and evaluate errors. This library does not allow developers to decide if an error is exceptional or not in their applications.

```elixir
defmodule MyModule do
  def janky_function(value) do
    if is_integer(value) do
      # ...
      "Result..."
    else
      raise RuntimeError, message: "invalid argument. Is not integer!"
    end
  end
end
```

```elixir
defmodule Client do
  # Client forced to use exceptions for control-flow.
  def foo(arg) do
    try do
      value = MyModule.janky_function(arg)
      "All good! #{value}."
    rescue
      e in RuntimeError ->
        reason = e.message
        "Uh oh! #{reason}."
    end
  end
end

# ...Use examples...

Client.foo(1)
# "All good! Result...."

Client.foo("lucas")
# "Uh oh! invalid argument. Is not integer!."
```

* __Refactoring:__ Library authors should guarantee that clients are not required to use exceptions for control-flow in their applications. As shown below, this can be done by refactoring the library `MyModule`, providing two versions of the function that forces clients to use exceptions for control-flow (e.g., `janky_function`). 1) a version with the raised exceptions should have the same name as the smelly one, but with a trailing `!` (i.e., `janky_function!`); 2) Another version, without raised exceptions, should have a name identical to the original version (i.e., `janky_function`), and should return the result wrapped in a tuple.

```elixir
defmodule MyModule do
  @moduledoc """
    Refactored library
  """

  @doc """
    Refactored version without exceptions for control-flow.
  """
  def janky_function(value) do
    if is_integer(value) do
      # ...
      {:ok, "Result..."}
    else
      {:error, "invalid argument. Is not integer!"}
    end
  end

  def janky_function!(value) do
    case janky_function(value) do
      {:ok, result} ->
        result

      {:error, message} ->
        raise RuntimeError, message: message
    end
  end
end
```

This refactoring gives clients more freedom to decide how to proceed in the event of errors, defining what is exceptional or not in different situations. As shown next, when an error is not exceptional, clients can use specific control-flow structures, such as the `case` statement along with pattern matching.

```elixir
defmodule Client do
  # Clients now can also choose to use control-flow structures
  # for control-flow when an error is not exceptional.
  def foo(arg) do
    case MyModule.janky_function(arg) do
      {:ok, value} -> "All good! #{value}."
      {:error, reason} -> "Uh oh! #{reason}."
    end
  end
end

# ...Use examples...

Client.foo(1)
# "All good! Result...."

Client.foo("lucas")
# "Uh oh! invalid argument. Is not integer!."
```

This example is based on code written by Tim Austin <sup>[neenjaw](https://exercism.org/profiles/neenjaw)</sup> and Angelika Tyborska <sup>[angelikatyborska](https://exercism.org/profiles/angelikatyborska)</sup>. Source: [link](https://exercism.org/tracks/elixir/concepts/try-rescue)

<!-- livebook:{"branch_parent_index":1} -->

## Untested polymorphic behavior

* __Category:__ Design-related smell.

* __Problem:__ This code smell refers to functions that have protocol-dependent parameters and are therefore polymorphic. A polymorphic function itself does not represent a code smell, but some developers implement these generic functions without accompanying guard clauses, allowing to pass parameters that do not implement the required protocol or that have no meaning.

* __Example:__ An instance of this code smell happens when a function uses `to_string()` to convert data received by parameter. The function `to_string()` uses the protocol `String.Chars` for conversions. Many Elixir data types (e.g., `BitString`, `Integer`, `Float`, `URI`) implement this protocol. However, as shown below, other Elixir data types (e.g., `Map`) do not implement it and can cause an error in `dasherize/1` function. Depending on the situation, this behavior can be desired or not. Besides that, it may not make sense to dasherize a `URI` or a number as shown next.

```elixir
defmodule CodeSmells do
  def dasherize(data) do
    to_string(data)
    |> String.replace("_", "-")
  end
end

# ...Use examples...

CodeSmells.dasherize("Lucas_Vegi")
# "Lucas-Vegi"

# <= Makes sense?
CodeSmells.dasherize(10)
# "10"

# <= Makes sense?
CodeSmells.dasherize(URI.parse("http://www.code_smells.com"))
# "http://www.code-smells.com"

CodeSmells.dasherize(%{last_name: "vegi", first_name: "lucas"})
# ** (Protocol.UndefinedError) protocol String.Chars not implemented 
# for %{first_name: "lucas", last_name: "vegi"} of type Map
```

* __Refactoring:__ There are two main alternatives to improve code affected by this smell. __1)__ You can either remove the protocol use (i.e., `to_string/1`), by adding multi-clauses on `dasherize/1` or just remove it; or __2)__ You can document that `dasherize/1` uses the protocol `String.Chars` for conversions, showing its consequences. As shown next, we refactored using the first alternative, removing the protocol and restricting `dasherize/1` parameter only to desired data types (i.e., `BitString` and `Atom`). Besides that, we use `@doc` to validate `dasherize/1` for desired inputs and to document the behavior to some types that we think don't make sense for the function (e.g., `Integer` and `URI`).

```elixir
defmodule CodeSmells do
  @doc """
    Function that converts underscores to dashes.

    ## Parameter
      data: only BitString and Atom are supported.

    ## Examples

        iex> CodeSmells.dasherize(:lucas_vegi)
        "lucas-vegi"

        iex> CodeSmells.dasherize("Lucas_Vegi")
        "Lucas-Vegi"

        iex> CodeSmells.dasherize(%{last_name: "vegi", first_name: "lucas"})
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1

        iex> CodeSmells.dasherize(URI.parse("http://www.code_smells.com"))
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1

        iex> CodeSmells.dasherize(10)
        ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1
  """
  def dasherize(data) when is_atom(data) do
    dasherize(Atom.to_string(data))
  end

  def dasherize(data) when is_binary(data) do
    String.replace(data, "_", "-")
  end
end

# ...Use examples...

CodeSmells.dasherize(:lucas_vegi)
# "lucas-vegi"

CodeSmells.dasherize("Lucas_Vegi")
# "Lucas-Vegi"

CodeSmells.dasherize(10)
# ** (FunctionClauseError) no function clause matching in CodeSmells.dasherize/1
```

This example is based on code written by José Valim ([@josevalim](https://github.com/josevalim)). Source: [link](http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/)

<!-- livebook:{"branch_parent_index":1} -->

## Alternative return types

* __Category:__ Design-related smell.

* __Note:__ This smell was suggested by the community via issues ([#6](https://github.com/lucasvegi/Elixir-Code-Smells/issues/6)).

* __Problem:__ This code smell refers to functions that receive options (e.g., `keyword list`) parameters that drastically change its return type. Because options are optional and sometimes set dynamically, if they change the return type it may be hard to understand what the function actually returns.

* __Example:__ An example of this code smell, as shown below, is when a library (e.g. `AlternativeInteger`) has a multi-clause function `parse/2` with many alternative return types. Depending on the options received as a parameter, the function will have a different return type.

```elixir
defmodule AlternativeInteger do
  def parse(string, opts) when is_list(opts) do
    case opts[:discard_rest] do
      # only an integer value convert from string parameter
      true -> String.to_integer(string)
      # another return type (e.g., tuple)
      _ -> {String.to_integer(string)}
    end
  end

  def parse(string, opts \\ :default) do
    # another return type (e.g., tuple)
  end
end

# ...Use examples...

AlternativeInteger.parse("13")
# {13, "..."}

AlternativeInteger.parse("13", discard_rest: true)
# 13

AlternativeInteger.parse("13", discard_rest: false)
# {13, "..."}
```

* __Refactoring:__ To refactor this smell, as shown next, it's better to add in the library a specific function for each return type (e.g., `parse_no_rest/1`), no longer delegating this to an options parameter.

```elixir
defmodule AlternativeInteger do
  def parse_no_rest(string) do
    # only an integer value convert from string parameter
    String.to_integer(string)
  end

  def parse(string) do
    # another return type (e.g., tuple)
    {String.to_integer(string)}
  end
end

# ...Use examples...

AlternativeInteger.parse("13")
# {13, "..."}

AlternativeInteger.parse_no_rest("13")
# 13
```

This example and the refactoring are proposed by José Valim ([@josevalim](https://github.com/josevalim))

<!-- livebook:{"branch_parent_index":1} -->

## Code organization by process

* __Category:__ Design-related smell.

* __Problem:__ This smell refers to code that is unnecessarily organized by processes. A process itself does not represent a code smell, but it should only be used to model runtime properties (e.g., concurrency, access to shared resources, event scheduling). When a process is used for code organization, it can create bottlenecks in the system.

* __Example:__ An example of this code smell, as shown below, is a library that implements arithmetic operations (e.g., add, subtract) by means of a `GenSever` process<sup>[link](https://hexdocs.pm/elixir/master/GenServer.html)</sup>. If the number of calls to this single process grows, this code organization can compromise the system performance, therefore becoming a bottleneck.

```elixir
defmodule Calculator do
  use GenServer

  @moduledoc """
    Calculator that performs two basic arithmetic operations.
    This code is unnecessarily organized by a GenServer process.
  """

  @doc """
    Function to perform the sum of two values.
  """
  def add(a, b, pid) do
    GenServer.call(pid, {:add, a, b})
  end

  @doc """
    Function to perform subtraction of two values.
  """
  def subtract(a, b, pid) do
    GenServer.call(pid, {:subtract, a, b})
  end

  def init(init_arg) do
    {:ok, init_arg}
  end

  def handle_call({:add, a, b}, _from, state) do
    {:reply, a + b, state}
  end

  def handle_call({:subtract, a, b}, _from, state) do
    {:reply, a - b, state}
  end
end

# Start a generic server process
{:ok, pid} = GenServer.start_link(Calculator, :init)
# {:ok, #PID<0.132.0>}

# ...Use examples...
Calculator.add(1, 5, pid)
# 6

Calculator.subtract(2, 3, pid)
# -1
```

* __Refactoring:__ In Elixir, as shown next, code organization must be done only by modules and functions. Whenever possible, a library should not impose specific behavior (such as parallelization) on its clients. It is better to delegate this behavioral decision to the developers of clients, thus increasing the potential for code reuse of a library.

```elixir
defmodule Calculator do
  def add(a, b) do
    a + b
  end

  def subtract(a, b) do
    a - b
  end
end

# ...Use examples...

Calculator.add(1, 5)
# 6

Calculator.subtract(2, 3)
# -1
```

This example is based on code provided in Elixir's official documentation. Source: [link](https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-using-processes-for-code-organization)

<!-- livebook:{"branch_parent_index":1} -->

## Data manipulation by migration

* __Category:__ Design-related smell.

* __Problem:__ This code smell refers to modules that perform both data and structural changes in a database schema via `Ecto.Migration`<sup>[link](https://hexdocs.pm/ecto_sql/Ecto.Migration.html)</sup>. Migrations must be used exclusively to modify a database schema over time (e.g., by including or excluding columns and tables). When this responsibility is mixed with data manipulation code, the module becomes less cohesive, more difficult to test, and therefore more prone to bugs.

* __Example:__ An example of this code smell is when an `Ecto.Migration` is used simultaneously to alter a table, adding a new column to it, and also to update all pre-existing data in that table, assigning a value to this new column. As shown below, in addition to adding the `is_custom_shop` column in the `guitars` table, this `Ecto.Migration` changes the value of this column for some specific guitar models.

  ```elixir
  defmodule GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars do
    use Ecto.Migration

    import Ecto.Query
    alias GuitarStore.Inventory.Guitar
    alias GuitarStore.Repo

    @doc """
      A function that modifies the structure of table "guitars",
      adding column "is_custom_shop" to it. By default, all data
      pre-stored in this table will have the value false stored
      in this new column.

      Also, this function updates the "is_custom_shop" column value
      of some guitar models to true.
    """
    def change do
      alter table("guitars") do
        add :is_custom_shop, :boolean, default: false
      end
      create index("guitars", ["is_custom_shop"])

      custom_shop_entries()
      |> Enum.map(&update_guitars/1)
    end

    @doc """
      A function that updates values of column "is_custom_shop" to true.
    """
    defp update_guitars({make, model, year}) do
      from(g in Guitar,
        where: g.make == ^make and g.model == ^model and g.year == ^year,
        select: g
      )
      |> Repo.update_all(set: [is_custom_shop: true])
    end

    @doc """
      Function that defines which guitar models that need to have the values
      of the "is_custom_shop" column updated to true.
    """
    defp custom_shop_entries() do
      [
        {"Gibson", "SG", 1999},
        {"Fender", "Telecaster", 2020}
      ]
    end
  end
  ```

  You can run this smelly migration above by going to the root of your project and typing the next command via console:

  ```elixir
    mix ecto.migrate
  ```

* __Refactoring:__ To remove this code smell, it is necessary to separate the data manipulation in a `mix task` <sup>[link](https://hexdocs.pm/mix/Mix.html#module-mix-task)</sup> different from the module that performs the structural changes in the database via `Ecto.Migration`. This separation of responsibilities is a best practice for increasing code testability. As shown below, the module `AddIsCustomShopToGuitars` now use `Ecto.Migration` only to perform structural changes in the database schema:

  ```elixir
  defmodule GuitarStore.Repo.Migrations.AddIsCustomShopToGuitars do
    use Ecto.Migration

    @doc """
      A function that modifies the structure of table "guitars",
      adding column "is_custom_shop" to it. By default, all data
      pre-stored in this table will have the value false stored
      in this new column.
    """
    def change do
      alter table("guitars") do
        add :is_custom_shop, :boolean, default: false
      end

      create index("guitars", ["is_custom_shop"])
    end
  end
  ```

  Furthermore, the new mix task `PopulateIsCustomShop`, shown next, has only the responsibility to perform data manipulation, thus improving testability:

  ```elixir
  defmodule Mix.Tasks.PopulateIsCustomShop do
    @shortdoc "Populates is_custom_shop column"

    use Mix.Task

    import Ecto.Query
    alias GuitarStore.Inventory.Guitar
    alias GuitarStore.Repo

    @requirements ["app.start"]

    def run(_) do
      custom_shop_entries()
      |> Enum.map(&update_guitars/1)
    end

    defp update_guitars({make, model, year}) do
      from(g in Guitar,
        where: g.make == ^make and g.model == ^model and g.year == ^year,
        select: g
      )
      |> Repo.update_all(set: [is_custom_shop: true])
    end

    defp custom_shop_entries() do
      [
        {"Gibson", "SG", 1999},
        {"Fender", "Telecaster", 2020}
      ]
    end
  end
  ```

  You can run this `mix task` above by typing the next command via console:

  ```elixir
    mix populate_is_custom_shop
  ```

  This example is based on code originally written by Carlos Souza. Source: [link](https://www.idopterlabs.com.br/post/criando-uma-mix-task-em-elixir)
